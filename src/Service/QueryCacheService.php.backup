<?php

namespace App\Service;

use Psr\Cache\CacheItemPoolInterface;
use Psr\Log\LoggerInterface;
use Symfony\Contracts\Cache\ItemInterface;

class QueryCacheService
{
    private CacheItemPoolInterface $cache;
    private LoggerInterface $logger;
    private int $defaultTtl;

    public function __construct(
        CacheItemPoolInterface $cache,
        LoggerInterface $logger,
        int $defaultTtl = 300 // 5 minutes default
    ) {
        $this->cache = $cache;
        $this->logger = $logger;
        $this->defaultTtl = $defaultTtl;
    }

    /**
     * Cache a query result
     */
    public function cacheQuery(string $key, callable $queryCallback, int $ttl = null): mixed
    {
        $ttl = $ttl ?? $this->defaultTtl;
        
        try {
            $item = $this->cache->getItem($this->normalizeKey($key));
            
            if (!$item->isHit()) {
                $this->logger->info("Cache MISS for key: {$key}");
                $result = $queryCallback();
                $item->set($result);
                $item->expiresAfter($ttl);
                $this->cache->save($item);
            } else {
                $this->logger->info("Cache HIT for key: {$key}");
            }
            
            return $item->get();
        } catch (\Exception $e) {
            $this->logger->error("Cache error for key {$key}: " . $e->getMessage());
            // Fallback to direct query execution
            return $queryCallback();
        }
    }

    /**
     * Cache user-specific query
     */
    public function cacheUserQuery(int $userId, string $queryName, callable $queryCallback, int $ttl = null): mixed
    {
        $key = "user_{$userId}_{$queryName}";
        return $this->cacheQuery($key, $queryCallback, $ttl);
    }

    /**
     * Cache analytics query
     */
    public function cacheAnalyticsQuery(string $queryName, callable $queryCallback, int $ttl = 600): mixed
    {
        $key = "analytics_{$queryName}";
        return $this->cacheQuery($key, $queryCallback, $ttl);
    }

    /**
     * Cache dashboard statistics
     */
    public function cacheDashboardStats(int $userId, callable $statsCallback, int $ttl = 300): array
    {
        return $this->cacheUserQuery($userId, 'dashboard_stats', $statsCallback, $ttl);
    }

    /**
     * Cache task list query
     */
    public function cacheTaskList(int $userId, array $filters, callable $queryCallback, int $ttl = 120): array
    {
        $filterKey = md5(serialize($filters));
        $key = "user_{$userId}_tasks_{$filterKey}";
        return $this->cacheQuery($key, $queryCallback, $ttl);
    }

    /**
     * Invalidate specific cache key
     */
    public function invalidate(string $key): bool
    {
        try {
            $normalizedKey = $this->normalizeKey($key);
            $result = $this->cache->deleteItem($normalizedKey);
            $this->logger->info("Cache invalidated for key: {$key}");
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("Cache invalidation error for key {$key}: " . $e->getMessage());
            return false;
        }
    }

    /**
     * Invalidate user-specific cache
     */
    public function invalidateUserCache(int $userId): void
    {
        // In a real implementation, you'd use cache tags or pattern-based deletion
        // For now, we'll log the invalidation
        $this->logger->info("Invalidating cache for user {$userId}");
    }

    /**
     * Invalidate all analytics cache
     */
    public function invalidateAnalyticsCache(): void
    {
        // This would require cache tagging or pattern matching
        $this->logger->info("Invalidating analytics cache");
    }

    /**
     * Get cache statistics
     */
    public function getCacheStats(): array
    {
        // This is a simplified implementation
        // In production, you'd integrate with your cache provider's stats
        return [
            'provider' => get_class($this->cache),
            'default_ttl' => $this->defaultTtl
        ];
    }

    /**
     * Normalize cache key to ensure it's valid
     */
    private function normalizeKey(string $key): string
    {
        // Replace invalid characters and ensure reasonable length
        $key = preg_replace('/[^a-zA-Z0-9_\-\.]/', '_', $key);
        return substr($key, 0, 250); // Limit key length
    }

    /**
     * Cache warming for critical queries
     */
    public function warmCache(callable $warmupCallback): void
    {
        try {
            $this->logger->info("Starting cache warmup");
            $warmupCallback($this);
            $this->logger->info("Cache warmup completed");
        } catch (\Exception $e) {
            $this->logger->error("Cache warmup failed: " . $e->getMessage());
        }
    }

    /**
     * Create composite cache key
     */
    public function createCompositeKey(string ...$parts): string
    {
        return implode('_', $parts);
    }

    /**
     * Cache with automatic key generation based on parameters
     */
    public function cacheWithAutoKey(string $prefix, array $parameters, callable $queryCallback, int $ttl = null): mixed
    {
        $key = $prefix . '_' . md5(serialize($parameters));
        return $this->cacheQuery($key, $queryCallback, $ttl);
    }

    /**
     * Batch cache multiple queries
     */
    public function batchCache(array $queries): array
    {
        $results = [];
        
        foreach ($queries as $key => $queryConfig) {
            $callback = $queryConfig['callback'];
            $ttl = $queryConfig['ttl'] ?? null;
            $results[$key] = $this->cacheQuery($key, $callback, $ttl);
        }
        
        return $results;
    }

    /**
     * Check if cache item exists
     */
    public function has(string $key): bool
    {
        try {
            return $this->cache->hasItem($this->normalizeKey($key));
        } catch (\Exception $e) {
            $this->logger->error("Cache check error for key {$key}: " . $e->getMessage());
            return false;
        }
    }

    /**
     * Invalidate specific cache key
     */
    public function invalidate(string $key): bool
    {
        try {
            $normalizedKey = $this->normalizeKey($key);
            $result = $this->cache->deleteItem($normalizedKey);
            $this->logger->info("Cache invalidated for key: {$key}");
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("Cache invalidation error for key {$key}: " . $e->getMessage());
            return false;
        }
    }
    
    /**
     * Clear all cache
     */
    public function clear(): bool
    {
        try {
            $result = $this->cache->clear();
            $this->logger->info("Cache cleared");
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("Cache clear error: " . $e->getMessage());
            return false;
        }
    }
}